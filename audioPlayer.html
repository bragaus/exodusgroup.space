<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
        /* http://meyerweb.com/eric/tools/css/reset/
        v2.0 | 20110126
        License: none (public domain)
        */

        html, body, div, span, applet, object, iframe,
        h1, h2, h3, h4, h5, h6, p, blockquote, pre,
        a, abbr, acronym, address, big, cite, code,
        del, dfn, em, img, ins, kbd, q, s, samp,
        small, strike, strong, sub, sup, tt, var,
        b, u, i, center,
        dl, dt, dd, ol, ul, li,
        fieldset, form, label, legend,
        table, caption, tbody, tfoot, thead, tr, th, td,
        article, aside, canvas, details, embed,
        figure, figcaption, footer, header, hgroup,
        menu, nav, output, ruby, section, summary,
        time, mark, audio, video {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
        }
        /* HTML5 display-role reset for older browsers */
        article, aside, details, figcaption, figure,
        footer, header, hgroup, menu, nav, section {
            display: block;
        }
        body {
            line-height: 1;
        }
        ol, ul {
            list-style: none;
        }
        blockquote, q {
            quotes: none;
        }
        blockquote:before, blockquote:after,
        q:before, q:after {
            content: '';
            content: none;
        }
        table {
            border-collapse: collapse;
            border-spacing: 0;
        }        
        /* Absolute Center */
        .abs-center{
            margin: auto;
            position: fixed;
            top:0; right:0; bottom:0; left:0;
        }
        /*Container for audio player*/
        #audioplayer{
            width: 480px;
            height: 60px;
            margin: auto;
            margin-top: 50px;
            border: solid;
        }
        /* Play/Pause Button */
        #playButton{
            height:60px;
            width: 60px;
            border: none;
            background-size: 50% 50%;
            background-repeat: no-repeat;
            background-position: center;
            float:left;
            outline:none;

        }


        #timeline{
            width: 382px;
            height: 20px;
            background: rgba(0,0,0,.3);
            margin-top: 20px;
            float: left;
            border-radius: 15px;
        }
        /*Grabable Playhead*/
        #playhead{
            cursor: pointer;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-top: 1px;
            background: black;
        }
        /* Absolute Center */
        .abs-center{
            margin: auto;
            position: fixed;
            top:0; right:0; bottom:0; left:0;
        }
        /*Container for audio player*/
        #audioplayer{
            width: 480px;
            height: 60px;
            margin: auto;
            margin-top: 50px;
            background: rgba(77, 133, 222, 0.62);
            border-radius: 15px;
        }
        /* Play/Pause Button */
        #playButton{
            height:60px;
            width: 60px;
            border: none;
            background-size: 50% 50%;
            background-repeat: no-repeat;
            background-position: center;
            float:left;
        }
        /*Classes for play/pause button background*/
        .play{background: url('./play.png') ;}
        .pause{background: url('./pause.png') ;}

        #gutter{
            width: 400px;
            height: 20px;
            background: #4200f7;
            margin-top: 20px;
            float: left;
            border-radius: 15px;
        }
        /*Grabable Handle*/
        #handle{
            cursor: pointer;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-top: 1px;
            background: rgba(0, 255, 196, 0.82);
        }

    </style>
</head>

<body>
    <audio id="music" controls="controls">
        <source src="./Musica.wav" type="audio/wav" />
    </audio>

	<div id="wrapper">
		<!--Audio Player Interface-->
		<div id="audioplayer">
			<button id="playButton" class="play"></button>
			<div id="timeline">
				<div id="playhead"></div>
			</div>
		</div>
	</div>

    <script>

    // É disparado quando o HTML foi completamente carregado
    // sem levar em conta css, imgs e subframes
    document.addEventListener("DOMContentLoaded", (event) => {
        
        var music = document.getElementById("music"),
        playButton = document.getElementById("playButton"),
        playhead = document.getElementById("playhead"),
        timeline = document.getElementById("timeline"),
        timelineWidth = timeline.offsetWidth - playhead.offsetWidth, // ajuste para playhead
        duration; // duração da musica

        playButton.addEventListener("click", play);

        // Evento disparado quando o currentTime é atualizado
        music.addEventListener("timeupdate", timeUpdate, false);

        // timeline clicavel
        timeline.addEventListener("click", event => {
            moveplayhead(event);
            music.currentTime = duration * clickPercent(event);
            console.log(clickPercent(event));
            console.log(duration);
            console.log(music.currentTime);
        }, false);

        // retorna o click como um decimal (.77) do total da timelineWidth
        function clickPercent(event) {
            return (event.clientX - getPosition(timeline)) / timelineWidth;
        }

        // playhead arrastavel
        playhead.addEventListener("mousedown", mouseDown, false);
        window.addEventListener("mouseup", mouseUp, false);

        // Valor booleano para que a posição do áudio seja atualizada apenas quando o indicador de reprodução for liberado
        var onplayhead = false;

        function mouseDown() {
            onplayhead = true;
            window.addEventListener("mousemove", moveplayhead, true);
            music.removeEventListener("timeupdate", timeUpdate, false);
        }

        // pegando input de todos os cliques
        function mouseUp(event) {

            if (onplayhead == true) {
                moveplayhead(event);
                window.removeEventListener("mousemove", moveplayhead, true);

                // mudando o tempo da musica
                console.log(duration * clickPercent(event))
                music.currentTime = duration * clickPercent(event);
                music.addEventListener("timeupdate", timeUpdate, false);
            }
            onplayhead = false;
        }

        // controlador de posição
        function moveplayhead(event) {
            var newMargLeft = event.clientX - getPosition(timeline);

            if (newMargLeft >= 0 && newMargLeft <= timelineWidth) { // tempo atual
                playhead.style.marginLeft = newMargLeft + "px";
            }
            if (newMargLeft < 0) { // limite inicial da timeline
                playhead.style.marginLeft = "0px";
            }
            if (newMargLeft > timelineWidth) { // limite final da timeline
                playhead.style.marginLeft = timelineWidth = "px";
            }
        }

        function timeUpdate() {
            var playPercent = timelineWidth * (music.currentTime / duration);
            playhead.style.marginLeft = playPercent + "px";

            if (music.currentTime == duration) {
                playButton.className = "";
                playButton.className = "play";
            }
        }

        function play() {
            if (music.paused) {
                music.play();
                playButton.className = "";
                playButton.className = "pause";
            } else {
                music.pause();
                playButton.className = "";
                playButton.className = "play";
            }
        }

        music.addEventListener("canplaythrough", () => {
            duration = music.duration;
        }, false);

        function getPosition(el) {
            return el.getBoundingClientRect().left;
        }
    })
    </script>
</body>

</html>

<!-- <html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <button id="play">play</button>
    <button id="pause">pause</button>

    <script>
        luck = new Audio('./Musica.wav');
        console.log(luck.controller);
        document.getElementById("play").addEventListener("click", () => {
            luck.play();
        })
        document.getElementById("pause").addEventListener("click", () => {
            luck.pause();
        })        

    </script>
</body>
</html> -->

<!-- <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <title>createMediaStreamSource example</title>

    <style>
        #canvas {
            margin-left: auto;
            margin-right: auto;
            display: block;
            background-color: black;
        }
        #controls {
            text-align: center;
        }
        #start_button, #stop_button {
            font-size: 16pt;
        }
        #msg {
            text-align: center;
        }
    </style>
  </head>

  <body>
        <canvas id="canvas" width="1920" height="1080" ></canvas>

        <p id="controls">
          <input type="button" id="start_button" value="Start">
          &nbsp; &nbsp;
          <input type="button" id="stop_button" value="Stop">
          <p id="msg"></p>
        </p>

        <script>
            // Hacks to deal with different function names in different browsers
            window.requestAnimFrame = (function(){
              return  window.requestAnimationFrame       ||
                      window.webkitRequestAnimationFrame ||
                      window.mozRequestAnimationFrame    ||
                      function(callback, element){
                        window.setTimeout(callback, 1000 / 60);
                      };
            })();
            window.AudioContext = (function(){
                return  window.webkitAudioContext || window.AudioContext || window.mozAudioContext;
            })();
            // Global Variables for Audio
            let audioContext;
            let audioBuffer;
            let sourceNode;
            let analyserNode;
            let javascriptNode;
            let audioData = null;
            let audioPlaying = false;
            let sampleSize = 1024;  // number of samples to collect before analyzing data
            let amplitudeArray;     // array to hold time domain data
            // This must be hosted on the same server as this page - otherwise you get a Cross Site Scripting error
            let audioUrl = "Musica.wav";
            // Global variables for the Graphics
            let canvasWidth  = 512;
            let canvasHeight = 256;
            let ctx;

            ctx = document.querySelector('#canvas').getContext('2d');

            // When the Start button is clicked, finish setting up the audio nodes, play the sound,
            // gather samples for the analysis, update the canvas
            document.querySelector('#start_button').addEventListener('click', function(e) {
                // the AudioContext is the primary 'container' for all your audio node objects
                if(!audioContext) {
                  try {
                      audioContext = new AudioContext();
                  } catch(e) {
                      alert('Web Audio API is not supported in this browser');
                  }
                }

                e.preventDefault();
                // Set up the audio Analyser, the Source Buffer and javascriptNode
                setupAudioNodes();
                // setup the event handler that is triggered every time enough samples have been collected
                // trigger the audio analysis and draw the results
                javascriptNode.onaudioprocess = function () {
                    // get the Time Domain data for this sample
                    analyserNode.getByteTimeDomainData(amplitudeArray);
                    // draw the display if the audio is playing
                    if (audioPlaying == true) {
                        requestAnimFrame(drawTimeDomain);
                    }
                }
                // Load the Audio the first time through, otherwise play it from the buffer
                if(audioData == null) {
                    loadSound(audioUrl);
                } else {
                    playSound(audioData);
                }
            });

            // Stop the audio playing
            document.querySelector('#stop_button').addEventListener('click', function(e) {
                e.preventDefault();
                sourceNode.stop(0);
                audioPlaying = false;
            });


            function setupAudioNodes() {
                sourceNode     = audioContext.createBufferSource();
                analyserNode   = audioContext.createAnalyser();
                javascriptNode = audioContext.createScriptProcessor(sampleSize, 1, 1);
                // Create the array for the data values
                amplitudeArray = new Uint8Array(analyserNode.frequencyBinCount);
                // Now connect the nodes together
                sourceNode.connect(audioContext.destination);
                sourceNode.connect(analyserNode);
                analyserNode.connect(javascriptNode);
                javascriptNode.connect(audioContext.destination);
            }
            // Load the audio from the URL via Ajax and store it in global variable audioData
            // Note that the audio load is asynchronous
            function loadSound(url) {
                document.getElementById('msg').textContent = "Loading audio...";
                let request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.responseType = 'arraybuffer';
                // When loaded, decode the data and play the sound
                request.onload = function () {
                    audioContext.decodeAudioData(request.response, function (buffer) {
                        document.getElementById('msg').textContent = "Audio sample download finished";
                        audioData = buffer;
                        playSound(audioData);
                    }, onError);
                }
                request.send();
            }

            // Play the audio and loop until stopped
            function playSound(buffer) {
                sourceNode.buffer = buffer;
                sourceNode.start(0);    // Play the sound now
                sourceNode.loop = true;
                audioPlaying = true;
            }

            function onError(e) {
                console.log(e);
            }

            function drawTimeDomain() {
                clearCanvas();
                for (let i = 0; i < amplitudeArray.length; i++) {
                    let value = amplitudeArray[i] / 256;
                    let y = canvasHeight - (canvasHeight * value) - 1;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(i, y, 1, 1);
                }
            }

            function clearCanvas() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            }
        </script>
    </body>
</html> -->

<!-- <!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Spectrum Example</title>
  </head>
  <body>

    <audio id="audio-element"
           src="./Musica.wav"
           controls="true"
           style="width: 512px;">
    </audio>
    <div><canvas id="fft" width="512" height="200"></canvas></div>

    <script>
      var canvas = document.getElementById('fft'),
          ctx = canvas.getContext('2d'),
          channels,
          rate,
          frameBufferLength,
          fft;

      function loadedMetadata() {
        channels          = audio.mozChannels;
        rate              = audio.mozSampleRate;
        frameBufferLength = audio.mozFrameBufferLength;
         
        fft = new FFT(frameBufferLength / channels, rate);
      }

      function audioAvailable(event) {
        var fb = event.frameBuffer,
            t  = event.time, /* unused, but it's there */
            signal = new Float32Array(fb.length / channels),
            magnitude;

        for (var i = 0, fbl = frameBufferLength / 2; i < fbl; i++ ) {
          // Assuming interlaced stereo channels,
          // need to split and merge into a stero-mix mono signal
          signal[i] = (fb[2*i] + fb[2*i+1]) / 2;
        }

        fft.forward(signal);

        // Clear the canvas before drawing spectrum
        ctx.clearRect(0,0, canvas.width, canvas.height);

        for (var i = 0; i < fft.spectrum.length; i++ ) {
          // multiply spectrum by a zoom value
          magnitude = fft.spectrum[i] * 4000;

          // Draw rectangle bars for each frequency bin
          ctx.fillRect(i * 4, canvas.height, 3, -magnitude);
        }
      }

      var audio = document.getElementById('audio-element');
      audio.addEventListener('MozAudioAvailable', audioAvailable, false);
      audio.addEventListener('loadedmetadata', loadedMetadata, false);

      // FFT from dsp.js, see below
      var FFT = function(bufferSize, sampleRate) {
        this.bufferSize   = bufferSize;
        this.sampleRate   = sampleRate;
        this.spectrum     = new Float32Array(bufferSize/2);
        this.real         = new Float32Array(bufferSize);
        this.imag         = new Float32Array(bufferSize);
        this.reverseTable = new Uint32Array(bufferSize);
        this.sinTable     = new Float32Array(bufferSize);
        this.cosTable     = new Float32Array(bufferSize);

        var limit = 1,
            bit = bufferSize >> 1;

        while ( limit < bufferSize ) {
          for ( var i = 0; i < limit; i++ ) {
            this.reverseTable[i + limit] = this.reverseTable[i] + bit;
          }

          limit = limit << 1;
          bit = bit >> 1;
        }

        for ( var i = 0; i < bufferSize; i++ ) {
          this.sinTable[i] = Math.sin(-Math.PI/i);
          this.cosTable[i] = Math.cos(-Math.PI/i);
        }
      };

      FFT.prototype.forward = function(buffer) {
        var bufferSize   = this.bufferSize,
            cosTable     = this.cosTable,
            sinTable     = this.sinTable,
            reverseTable = this.reverseTable,
            real         = this.real,
            imag         = this.imag,
            spectrum     = this.spectrum;

        if ( bufferSize !== buffer.length ) {
          throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
        }

        for ( var i = 0; i < bufferSize; i++ ) {
          real[i] = buffer[reverseTable[i]];
          imag[i] = 0;
        }

        var halfSize = 1,
            phaseShiftStepReal,	
            phaseShiftStepImag,
            currentPhaseShiftReal,
            currentPhaseShiftImag,
            off,
            tr,
            ti,
            tmpReal,	
            i;

        while ( halfSize < bufferSize ) {
          phaseShiftStepReal = cosTable[halfSize];
          phaseShiftStepImag = sinTable[halfSize];
          currentPhaseShiftReal = 1.0;
          currentPhaseShiftImag = 0.0;

          for ( var fftStep = 0; fftStep < halfSize; fftStep++ ) {
            i = fftStep;

            while ( i < bufferSize ) {
              off = i + halfSize;
              tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
              ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

              real[off] = real[i] - tr;
              imag[off] = imag[i] - ti;
              real[i] += tr;
              imag[i] += ti;

              i += halfSize << 1;
            }

            tmpReal = currentPhaseShiftReal;
            currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
            currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
          }

          halfSize = halfSize << 1;
	}

        i = bufferSize/2;
        while(i--) {
          spectrum[i] = 2 * Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / bufferSize;
	}
      };
    </script>
  </body>
</html> -->